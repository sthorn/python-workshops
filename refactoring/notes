

Why?
* add structure; analogy with written English
* write once read often (including by others)
* example of well written code - should be readable

How?
* PEP8
* split complex expressions: 
  - variable names make the code easier to understand
* functions
  - names
  - docstrings
  - size (small)
  - a function should do one thing
  - iterative process of refining functions
* variable names
* comments: failure; sometimes necessary; remove commented out code
* duplicate code
* PyLint?

* Worked example (my code)
* PyCharm

* exceptions
* test driven design

* Clean Code
* Safari Books online ($399/year/user)

* Jupyter notebooks or Keynote?

-------
To find out:

* Rules for docstrings 
* Exception handling basics and best practice


-------
Code snippets
[test code in PyCharm or PyLint!]


def convert_value(value, suffix=''):
    """Convert string valued value and (optional) SI suffix to float
    e.g. 3K -> 3096"""
    
    multiplier = {'':1, k':1000, 'K':1024, 'm':1000**2, 'M':1024**2, 'g':1000**3, 'G':1024**3}
    return float(value) * multiplier[suffix]


# Say we come across this in a larger block of code. What does it do?
pattern = re.compile('.*vmem=(?P<value>[0-9\.]+)(?P<suffix>[GgMmKk]*).*')
match = pattern.match(string)
vmem = float(match.group('value')) * multiplier[match.group('suffix')]


# Compare with:
vmem = extract_metric_from_string(string, metric='vmem')


def extract_metric_from_string(string, metric):
    """Extract a Grid Engine host metric from a string
    available metrics are: vmem, ...
    """

    pattern = f'.*{metric}=(?P<value>[0-9\.]+)(?P<suffix>[GgMmKk]*).*'
    match = re.match(pattern, string)

    # Return None if pattern not found
    if match == None:
        return None

    # Check value found (exception?)
    value = match.group('value')

    has_suffix = 'suffix' in match.groupdict()
    suffix = match.group('suffix) if has_suffix else '' 

    return convert_value(value, suffix)  # bad function name


    




    




